//! Run a pre-mono pass on THIR the current crate.
//! In THIR, all operator overloads have been resolved to a function call, but we still may have
//! uninstantiated generic functions.
//!
//! This exists to give useful diagnostics without having to wait all the way until monomorphization
//! to give any feedback at all. This matters a lot for core, which has a bunch of generic
//! functions.
//!
//! This pass works an item-at-a-time, with little shared state.

use std::ops::ControlFlow;

use rustc_hir::def_id::{DefId, LocalDefId};
use rustc_hir::{HirId, OwnerId};
use rustc_infer::traits::{ImplSource, Obligation, ObligationCause, ObligationCauseCode};
use rustc_middle::middle::codegen_fn_attrs::ferrocene::{ValidatedStatus, item_is_validated};
use rustc_middle::span_bug;
use rustc_middle::thir::visit::Visitor as _;
use rustc_middle::thir::{self, Thir};
use rustc_middle::ty::adjustment::PointerCoercion;
use rustc_middle::ty::{
    self, Binder, ExistentialPredicate, ExistentialTraitRef, GenericArgs, GenericArgsRef, Instance,
    InstanceKind, PolyTraitRef, Ty, TyCtxt, TypeSuperVisitable as _, TypeVisitable as _,
    TypeVisitor, TypingEnv,
};
use rustc_span::Span;
use rustc_trait_selection::traits::{ObligationCtxt, SelectionContext};
use tracing::{debug, info};

use crate::ferrocene::{InstantiateResult, LintState, Use, UseKind};

pub(super) struct LintThir<'thir, 'tcx> {
    thir: &'thir Thir<'tcx>,
    linter: LintState<'tcx>,
    owner: OwnerId,
}

impl<'thir, 'tcx: 'thir> thir::visit::Visitor<'thir, 'tcx> for LintThir<'thir, 'tcx> {
    fn thir(&self) -> &'thir Thir<'tcx> {
        self.thir
    }

    fn visit_expr(&mut self, expr: &'thir thir::Expr<'tcx>) {
        let use_ = match self.find_unvalidated_use(expr) {
            None => return,
            Some(use_) => use_,
        };
        let hir_id = HirId { owner: self.owner, local_id: expr.temp_scope_id };
        debug!("id={hir_id:?}, kind={:?}", expr.kind);
        self.linter.check_use(hir_id, use_);
    }
}

impl<'thir, 'tcx: 'thir> LintThir<'thir, 'tcx> {
    /// Entrypoint.
    ///
    /// We need a separate `owner` to be able to synthesize `HirId`s from expression IDs.
    /// `item` might not be an owner if it's a closure.
    pub(super) fn check_item(tcx: TyCtxt<'tcx>, owner: OwnerId, item: LocalDefId) -> Option<()> {
        if tcx.sess.opts.test
            && tcx.entry_fn(()).and_then(|(id, _)| id.as_local()) == Some(owner.def_id)
        {
            // We don't lint `main` functions if they're a shim generated by the `--test` machinery.
            info!("treating libtest main function as unvalidated");
            return None;
        }

        let linter = LintState::new(tcx, item)?;
        // thir_body can return ErrorGuaranteed if this is a const block that failed evaluation.
        let body = tcx.thir_body(item).ok()?;
        let thir = &body.0.borrow();
        let mut visitor = LintThir { linter, thir, owner };
        for expr in &*thir.exprs {
            visitor.visit_expr(expr);
        }

        Some(())
    }

    fn find_unvalidated_use(&mut self, expr: &thir::Expr<'tcx>) -> Option<Use<'tcx>> {
        let tcx = self.linter.tcx;
        let mut span = expr.span;

        let use_kind = match expr.kind {
            thir::ExprKind::NamedConst { def_id, .. }
            | thir::ExprKind::StaticRef { def_id, .. } => {
                // Statics and constants have bodies, but they are always evaluated at compile time.
                // We argue to our assessor that means that the correct behavior is
                // validated whenever the const/static is used in a runtime function, so the
                // functions that generate the constant don't need to be tested separately.
                // The constants themselves execute no code at runtime, so mentioning them is ok.
                let unknown_fn = contains_unknown_fn(expr.ty)?;
                // However, it's possible for runtime code to access an unknown function type from
                // this constant. Ensure that it's marked with `prevalidated` so that its body gets
                // checked.
                UseKind::ContainsFnPtr(def_id, unknown_fn)
            }
            // TODO: maybe this is ok actually? We'll still check it when it's actually called...
            thir::ExprKind::ZstLiteral { .. } => match expr.ty.kind() {
                ty::FnDef(maybe_trait_fn, generic_args) => {
                    debug!("saw zst {:?}", expr.ty);
                    let fn_def =
                        self.get_concrete_fn_def(*maybe_trait_fn, generic_args, expr.span)?;
                    UseKind::Named(fn_def.def_id())
                }
                _ => span_bug!(expr.span, "called ZST literals should always be named functions"),
            },
            thir::ExprKind::Call { ty, .. } => {
                let instance = self.instance_of_ty(ty, expr.span)?;
                // we use a custom narrowed span here. it's the receiver that's unvalidated, not the
                // arguments.
                span = tcx.sess.source_map().span_until_char(expr.span, '(');

                debug!("saw call to {instance:?}");
                UseKind::Called(instance)
            }
            // We assume all closure definitions in this function are also certified.
            // However, we still need to check the closure body to make sure it doesn't call
            // uncertified functions.
            thir::ExprKind::Closure(ref expr) => {
                // Closures are never an owner, so we need to hang onto the original owner so that
                // our synthesized HirIds are valid.
                LintThir::check_item(tcx, self.owner, expr.closure_id);
                return None;
            }
            thir::ExprKind::PointerCoercion { cast: PointerCoercion::Unsize, source, .. } => {
                self.check_dyn_trait_coercion(expr, source)?
            }
            // Nothing to check.
            _ => return None,
        };

        Some(Use { kind: use_kind, span, from_instantiation: None })
    }

    /// Given a `source` expression that has an unsizing cast to `dest`, determine
    /// whether the cast if valid. If not, return a [`TraitObjectCast`](UseKind::TraitObjectCast) showing why not.
    ///
    /// This works in four main parts:
    /// 1. "Peel" as many types as possible. For example, if we are casting `Vec<Box<String>>` to
    ///    `Vec<Box<dyn Display + Clone + Sync>`, peel that to `String` and
    ///    `dyn Display + Clone + Sync`. We call these `coerce_src` and `coerce_dst`.
    /// 2. Determine all traits in `dest`'s type that have at least one method. For example,
    ///    `dyn Display + Clone + Sync` contains the traits `Display` and `Clone`.
    /// 3. For each trait, find `coerce_src`'s implementation of it. For example,
    ///    `impl Display for String`.
    /// 4. For each method in the impl, check whether it's validated. For example, we would check
    ///    `<String as Diplay>::fmt`, see that it's unvalidated, and return its `DefId` in the
    ///    `UseKind`.
    fn check_dyn_trait_coercion(
        &self,
        dest: &thir::Expr<'tcx>,
        source: thir::ExprId,
    ) -> Option<UseKind<'tcx>> {
        let tcx = self.linter.tcx;

        let source_ty = self.thir[source].ty;
        // c.f. https://rust-lang.zulipchat.com/#narrow/channel/182449-t-compiler.2Fhelp/topic/Get.20a.20type's.20impl.20for.20a.20trait/with/570837962
        let (coerce_src, coerce_dst) =
            tcx.struct_lockstep_tails_for_codegen(source_ty, dest.ty, self.typing_env());
        // TODO: this is *not* correct for types other than references
        // see https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html for a full list of types
        // we need to handle here. i think just raw pointers?
        let coerce_src = coerce_src.peel_refs();
        debug!(
            "saw unsized coercion from {source_ty:?} -> {:?} (peeled: {coerce_src:?} -> {coerce_dst:?})",
            dest.ty
        );

        if matches!(coerce_src.kind(), ty::Dynamic(..)) {
            // upcasting from a `dyn Trait` to a `dyn SuperTrait`.
            // We already checked this when we originally cast to `dyn Trait`.
            // TODO: I think we forget to check supertraits currently?
            return None;
        }

        let bound_traits = dyn_trait_refs(coerce_dst);
        for trait_ in bound_traits {
            let Some(first_method) = tcx
                .associated_item_def_ids(trait_.def_id())
                .iter()
                .find(|&id| tcx.def_kind(id).is_fn_like())
            else {
                // not possible to call any functions on this trait object, casting is always ok.
                continue;
            };
            let trait_ref = trait_.with_self_ty(tcx, coerce_src);
            let (impl_block, generics) = match self.find_trait_impl(trait_ref, dest.span) {
                Some(impl_) => impl_,
                // If we couldn't resolve the impl, we have to assume it's not validated.
                None => return Some(UseKind::TraitObjectCast(*first_method, coerce_src)),
            };
            if let Some(unvalidated) =
                self.find_unvalidated_impl_fn(impl_block, generics, dest.span)
            {
                return Some(UseKind::TraitObjectCast(unvalidated, coerce_src));
            }
        }
        None
    }

    /// Given an `impl`, find the first associated function that isn't validated.
    ///
    /// TODO: list all uncertified functions, not just the first.
    fn find_unvalidated_impl_fn(
        &self,
        impl_block: DefId,
        generics: GenericArgsRef<'tcx>,
        span: Span,
    ) -> Option<DefId> {
        let tcx = self.linter.tcx;

        // TODO: I don't think this handles default functions in trait items
        for &impl_fn in tcx.associated_item_def_ids(impl_block) {
            if !tcx.def_kind(impl_fn).is_fn_like() {
                debug!("ignoring non-fn {impl_fn:?}");
                continue;
            }

            if let Some(instance) = self.try_instantiate(impl_fn, generics, span).instance() {
                if matches!(
                    item_is_validated(tcx, instance.def_id()),
                    ValidatedStatus::Validated { .. }
                ) {
                    continue;
                }
            }

            debug!("found unvalidated method {impl_fn:?}");
            // This function in the impl needs to be marked with `prevalidated`.
            return Some(impl_fn);
        }
        return None;
    }

    /// Given a `Trait<Ty>` reference, find `impl Trait for Ty`.
    ///
    /// This calls into the [trait solver] to select a suitable impl block.
    ///
    /// c.f. [`hax::exporter::traits::resolution::shallow_resolve_trait_ref`](https://github.com/AeneasVerif/hax/blob/3c2b6f01af4a4362dd855b811aa910ad173d546f/frontend/exporter/src/traits/resolution.rs#L666)
    ///
    /// Ideally, this would never return None, but sometimes our code is buggy ... failures here
    /// only degrade the diagnostic, they don't cause soundness issues.
    ///
    /// [trait solver]: https://rustc-dev-guide.rust-lang.org/traits/resolution.html
    fn find_trait_impl(
        &self,
        trait_ref: PolyTraitRef<'tcx>,
        span: Span,
    ) -> Option<(DefId, GenericArgsRef<'tcx>)> {
        use rustc_infer::infer::TyCtxtInferExt;

        let tcx = self.linter.tcx;
        let (infcx, param_env) =
            tcx.infer_ctxt().ignoring_regions().build_with_typing_env(self.typing_env());
        debug!("resolving impl for {trait_ref:?}");

        // Find the impl block.
        let mut selcx = SelectionContext::new(&infcx);
        // TODO: i think 'item' might not be correct when checking closures? does it matter?
        // the docs say it's only used for region constraints ...
        // lcnr says this is fine because `cause` is only used for diagnostics anyway.
        let cause =
            ObligationCause::new(span, self.linter.item, ObligationCauseCode::ExprAssignable);
        // method selection doesn't care about regions.
        let trait_ref = tcx.instantiate_bound_regions_with_erased(trait_ref);
        let obligation = Obligation::new(tcx, cause, param_env, trait_ref);
        let selection = match selcx.select(&obligation) {
            Ok(selection) => selection?,
            Err(e) => {
                // this can happen if our `peel_refs` above was buggy. these errors are only for better
                // diagnostics, so just ignore the bug for now. we're going to lint later anyway.
                info!("type checking failed for trait upcast? {e:?}");
                return None;
            }
        };
        debug!("selected {selection:?}");

        // Sanity check: make sure all `where` clauses on our `impl` are upheld.
        let ocx = ObligationCtxt::new(&infcx);
        let impl_source = selection.map(|o| {
            debug!("registering obligation {o:?}");
            ocx.register_obligation(o)
        });
        let errors = ocx.evaluate_obligations_error_on_ambiguity();
        if !errors.is_empty() {
            // ditto as for our selection failure
            info!("impl obligations not met for trait upcast? {errors:?}");
            return None;
        }

        let normalized_impl =
            tcx.erase_and_anonymize_regions(infcx.resolve_vars_if_possible(impl_source));
        debug!("found impl {normalized_impl:?}");
        match normalized_impl {
            ImplSource::UserDefined(data) => Some((data.impl_def_id, data.args)),
            ImplSource::Param(_) => None,
            // TODO: what to do here? this shouldn't actually prevent the cast ...
            ImplSource::Builtin(..) => None,
        }
    }

    /// Given a call to a function-like type, return the instantiated function definition,
    /// or `None` if we can't find it until it's been monomorphized.
    ///
    /// Panics if given a type that isn't callable.
    fn instance_of_ty(&self, ty: Ty<'tcx>, span: Span) -> Option<Instance<'tcx>> {
        match ty.kind() {
            ty::FnDef(maybe_trait_fn, generic_args) => {
                let callee = self.get_concrete_fn_def(*maybe_trait_fn, generic_args, span)?;
                Some(callee)
            }
            // Reference to a function or function pointer.
            ty::Ref(_, ty, _) => self.instance_of_ty(*ty, span),
            // We assume that all functions pointers are valid. Proof:
            // 1. If the function was certified, no problem.
            // 2. If the function was uncertified, and is a literal or assigned to a local
            //    variable, then either:
            //    - We can resolve it to a concrete instance, in which case we would have caught it in ZstLiteral above.
            //    - We can't resolve it yet, but it stays a unique function type, so we will
            //    catch the call later in the post-mono pass.
            //    - We can't resolve it yet and it's cast to a function pointer so we don't
            //    have enough info to catch it post-mono when it's called. In this case we
            //    catch it in `ReifyFnPtr` above.
            // 3. If the function was passed as an argument, then either:
            //   - We were called by an uncertified function. No problem.
            //   - We were called by a certified function. This lint will run on that
            //   function too, and we will catch it there at the time it is checked /
            //   monomorphized.
            // 4. If this is a closure then either:
            //   - It was defined in this function, in which case we treat it as also
            //   certified.
            //   - It was passed as an argument, which is ok by 3).
            //   - It is a global const/static, so we catch it in NamedConst/StaticRef above.
            ty::FnPtr(..) => None,
            // TODO: do we need to handle closures?
            other => span_bug!(span, "unsupported call kind {other:?}"),
        }
    }

    /// Given the `DefId` of a function and its generic arguments, instantiate it.
    /// Return `None` if it can't be resolved until it's been monomorphized.
    fn get_concrete_fn_def(
        &self,
        maybe_trait_fn: DefId,
        generic_args: GenericArgsRef<'tcx>,
        span: Span,
    ) -> Option<Instance<'tcx>> {
        // Indeterminate results are handled later by a post-mono pass that checks the
        // instantiation is verified. For now just ignore errors.
        let callee = self.try_instantiate(maybe_trait_fn, generic_args, span).instance()?;

        // If this is a call to Fn/FnMut/FnOnce::call, then it's a type that implements
        // `fn_traits`, either a closure or a user-defined type. Allow closures but check
        // everything else.
        if self.linter.tcx.is_closure_like(callee.def_id()) {
            debug!("skipping closure {callee:?}");
            return None;
        }

        // Skip trait functions. These happen when we're calling the vtable of a `dyn` unsized
        // object. This case is caught below in `PointerCoercion::Unsize`.
        if matches!(callee.def, InstanceKind::Virtual(..)) {
            info!("skipping dyn assoc item {callee:?}");
            return None;
        }

        Some(callee)
    }

    /// Like `get_concrete_fn_def`, but works for things besides functions.
    fn try_instantiate(
        &self,
        def_id: DefId,
        args: &'tcx GenericArgs<'tcx>,
        span: Span,
    ) -> InstantiateResult<'tcx> {
        let tcx = self.linter.tcx;

        match Instance::try_resolve(tcx, self.typing_env(), def_id, args) {
            Err(_) => {
                // this happens when we hit the type length limit
                tcx.dcx().span_delayed_bug(
                    span,
                    format!("could not resolve instance ({def_id:?}, {args:?})"),
                );
                InstantiateResult::Err
            }
            Ok(None) => InstantiateResult::Indeterminate,
            Ok(Some(instance)) => InstantiateResult::Resolved(instance),
        }
    }

    fn typing_env(&self) -> TypingEnv<'tcx> {
        use rustc_middle::ty::TypingMode;
        let tcx = self.linter.tcx;

        // apparently the rest of THIR uses this? it has a comment saying it's wrong though...
        //let typing_mode = TypingMode::non_body_analysis();
        // this definitely works but there's scary comments about revealing opaque types
        // let env = TypingEnv::post_analysis(tcx, self.linter.owner);

        let typing_mode = TypingMode::typeck_for_body(tcx, self.linter.item);
        let param_env = tcx.param_env(self.linter.item);
        TypingEnv { typing_mode, param_env }
    }
}

/// Given a Rust type, find (at any level of nesting) `dyn Trait` objects contained within it that
/// have at least one method.
/// For example, `dyn Send + Sync + Display + Clone` would return `[Display, Clone]`.
fn dyn_trait_refs<'tcx>(ty: Ty<'tcx>) -> Vec<Binder<'tcx, ExistentialTraitRef<'tcx>>> {
    struct FindDynTraitVisitor;

    impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for FindDynTraitVisitor {
        type Result = ControlFlow<Vec<Binder<'tcx, ExistentialTraitRef<'tcx>>>>;

        fn visit_ty(&mut self, t: Ty<'tcx>) -> Self::Result {
            match t.kind() {
                ty::Dynamic(bound_predicates, _lifetime) => {
                    let mut traits = vec![];
                    for predicate in *bound_predicates {
                        debug!("considering {predicate:?}");
                        let trait_ = predicate
                            .map_bound(|p| match p {
                                // auto traits do not allow calling methods
                                ExistentialPredicate::AutoTrait(_) => None,
                                // We don't care about associated type bounds.
                                // They restrict which impl is selected, but that's all they do.
                                // We already require the implementation of the trait to be certified
                                // (that's the `Trait` predicate below), so which impl gets picked
                                // doesn't matter as long we know which one it is.
                                ExistentialPredicate::Projection(_) => None,
                                ExistentialPredicate::Trait(t) => Some(t),
                            })
                            .transpose();
                        if let Some(t) = trait_ {
                            // TODO: handle supertraits
                            traits.push(t);
                        }
                    }
                    // TODO: is it possible to have multiple Dynamic types in a single top-level
                    // type? how? maybe with an enum?
                    ControlFlow::Break(traits)
                }
                _ => t.super_visit_with(self),
            }
        }
    }

    let cf = ty.visit_with(&mut FindDynTraitVisitor);
    cf.break_value().unwrap_or_default()
}

/// Used to check whether a `const` or `static` has a function pointer callable at runtime.
///
/// c.f. Ty::contains_closure
fn contains_unknown_fn<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {
    struct ContainsUnknownFnVisitor;

    impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ContainsUnknownFnVisitor {
        type Result = ControlFlow<Ty<'tcx>>;

        fn visit_ty(&mut self, t: Ty<'tcx>) -> Self::Result {
            match t.kind() {
                ty::Dynamic(..) | ty::FnPtr(_, _) => ControlFlow::Break(t),
                _ => t.super_visit_with(self),
            }
        }
    }

    let cf = ty.visit_with(&mut ContainsUnknownFnVisitor);
    cf.break_value()
}
