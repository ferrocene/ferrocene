use rustc_hir::def::DefKind;
use rustc_hir::def_id::DefId;
use rustc_hir::{
    ForeignItem, ForeignItemKind, Item, ItemKind, Node, TraitFn, TraitItem, TraitItemKind,
};
use rustc_macros::{HashStable, TyDecodable, TyEncodable};
use rustc_span::{Span, Symbol, sym};
use tracing::info;

use crate::ty::TyCtxt;

#[derive(Clone, TyEncodable, TyDecodable, HashStable, Debug)]
pub struct Validated {
    // prevalidated: bool,
    // FIXME: exported_constraint, validated, standards, qualification levels, entrypoint
}

const VALIDATED_ATTR: &[Symbol; 2] = &[sym::ferrocene, sym::prevalidated];

pub enum ValidatedStatus {
    Validated { annotation: Option<Span> },
    Unvalidated,
}

impl ValidatedStatus {
    pub fn validated(self) -> bool {
        match self {
            ValidatedStatus::Validated { .. } => true,
            ValidatedStatus::Unvalidated => false,
        }
    }
}

/// Shared between `rustc_lint` and `rustc_codegen_ssa` attr parsing.
pub fn item_is_validated(tcx: TyCtxt<'_>, def_id: DefId) -> ValidatedStatus {
    // A closure is validated if the function it's defined in is validated.
    let owner = tcx.typeck_root_def_id(def_id);

    // Skip items synthesized by the compiler.
    let synthetic = match tcx.def_kind(owner) {
        DefKind::Ctor(..) | DefKind::SyntheticCoroutineBody => true,
        _ => tcx.intrinsic(owner).is_some(),
    };
    if synthetic {
        info!("skipping synthetic item {owner:?}");
        return ValidatedStatus::Validated { annotation: None };
    }

    // Skip intrinsics, extern functions, and associated functions with no default.
    // We only have to do this for local DefIds; nothing makes it to post-mono without a body unless
    // it's an intrinsic.
    if let Some(local) = owner.as_local() {
        match tcx.hir_node_by_def_id(local) {
            Node::Item(Item { kind: ItemKind::Fn { has_body: false, .. }, .. })
                // FIXME: ForeignItems should be an exported_constraint
                | Node::ForeignItem(ForeignItem { kind: ForeignItemKind::Fn(..), .. })
                | Node::TraitItem(TraitItem { kind: TraitItemKind::Fn(_, TraitFn::Required(_)), .. }) => {
                    info!("skipping item {owner:?}");
                    return ValidatedStatus::Validated { annotation: None };
                }
            _ => {},
        }
    }

    let validated_attr = &*VALIDATED_ATTR;
    let main = tcx.entry_fn(()).map(|(def_id, _kind)| def_id);

    let annotation = tcx.get_attrs_by_path(owner, validated_attr).next();
    let is_main = main.map_or(false, |main| main == owner);
    // We normally assume main functions are validated, but not for the
    // shim generated by `rustc --test`.
    let main_is_validated = is_main && !tcx.sess.opts.test;

    // uncertified functions are always allowed to call certified functions
    if annotation.is_some() || main_is_validated {
        ValidatedStatus::Validated { annotation: annotation.map(|attr| attr.span()) }
    } else {
        ValidatedStatus::Unvalidated
    }
}
