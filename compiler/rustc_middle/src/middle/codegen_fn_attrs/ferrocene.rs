use rustc_hir::attrs::AttributeKind;
use rustc_hir::def::DefKind;
use rustc_hir::def_id::DefId;
use rustc_hir::{
    ForeignItem, ForeignItemKind, Item, ItemKind, Node, TraitFn, TraitItem, TraitItemKind,
};
use rustc_macros::{HashStable, TyDecodable, TyEncodable};
use rustc_middle::ty::{self, TyCtxt};
use rustc_span::{Span, Symbol, sym};
use tracing::info;

#[derive(Clone, TyEncodable, TyDecodable, HashStable, Debug)]
pub struct Validated {
    // prevalidated: bool,
    // FIXME: exported_constraint, validated, standards, qualification levels, entrypoint
}

const VALIDATED_ATTR: &[Symbol; 2] = &[sym::ferrocene, sym::prevalidated];

pub enum ValidatedStatus {
    Validated { annotation: Option<Span> },
    Unvalidated,
}

impl ValidatedStatus {
    pub fn validated(self) -> bool {
        match self {
            ValidatedStatus::Validated { .. } => true,
            ValidatedStatus::Unvalidated => false,
        }
    }
}

/// Shared between `rustc_lint` and `rustc_codegen_ssa` attr parsing.
pub fn item_is_validated(tcx: TyCtxt<'_>, def_id: DefId) -> ValidatedStatus {
    // A closure is validated if the function it's defined in is validated.
    let owner = tcx.typeck_root_def_id(def_id);

    // Skip items synthesized by the compiler.
    let synthetic = match tcx.def_kind(owner) {
        DefKind::Ctor(..) | DefKind::SyntheticCoroutineBody => true,
        _ => tcx.intrinsic(owner).is_some(),
    };
    if synthetic {
        info!("skipping synthetic item {owner:?}");
        return ValidatedStatus::Validated { annotation: None };
    }

    // Skip intrinsics, extern functions, and associated functions with no default.
    // We only have to do this for local DefIds; nothing makes it to post-mono without a body unless
    // it's an intrinsic.
    if let Some(local) = owner.as_local() {
        match tcx.hir_node_by_def_id(local) {
            Node::Item(Item { kind: ItemKind::Fn { has_body: false, .. }, .. })
                // FIXME: ForeignItems should be an exported_constraint
                | Node::ForeignItem(ForeignItem { kind: ForeignItemKind::Fn(..), .. })
                | Node::TraitItem(TraitItem { kind: TraitItemKind::Fn(_, TraitFn::Required(_)), .. }) => {
                    info!("skipping item {owner:?}");
                    return ValidatedStatus::Validated { annotation: None };
                }
            _ => {},
        }

        // Check if this is an associated function from a `derive`.
        let parent = tcx.parent(owner);
        tracing::debug!("parent={parent:?}, kind={:?}", tcx.def_kind(parent));
        if matches!(tcx.def_kind(parent), DefKind::Impl { .. }) {
            tracing::debug!("attrs={:?}", tcx.get_all_attrs(parent));
        }
        let mut derived = false;
        if matches!(tcx.def_kind(parent), DefKind::Impl { .. }) {
            derived |= rustc_hir::find_attr!(
                tcx.get_all_attrs(parent),
                AttributeKind::AutomaticallyDerived { .. }
            );
        }
        if derived {
            let self_ty = tcx.type_of(parent);
            info!("checking {self_ty:?}");
            match self_ty.skip_binder().peel_refs().kind() {
                ty::Adt(adt_def, _) => {
                    let self_id = adt_def.did();
                    info!(
                        "{} is marked #[automatically_derived], checking {}",
                        tcx.def_path_str(def_id),
                        tcx.def_path_str(self_id)
                    );
                    return item_is_validated(tcx, self_id);
                }
                _ => {
                    let span = tcx.def_span(parent);
                    span_bug!(
                        span,
                        "don't know how to handle #[automatically_derived] for non-adt {self_ty:?}"
                    );
                }
            }
        }
    }

    let validated_attr = &*VALIDATED_ATTR;
    let main = tcx.entry_fn(()).map(|(def_id, _kind)| def_id);

    let annotation = tcx.get_attrs_by_path(owner, validated_attr).next();
    let is_main = main.map_or(false, |main| main == owner);
    // We normally assume main functions are validated, but not for the
    // shim generated by `rustc --test`.
    let main_is_validated = is_main && !tcx.sess.opts.test;

    // unvalidated functions are always allowed to call validated functions
    if annotation.is_some() || main_is_validated {
        ValidatedStatus::Validated { annotation: annotation.map(|attr| attr.span()) }
    } else {
        ValidatedStatus::Unvalidated
    }
}
