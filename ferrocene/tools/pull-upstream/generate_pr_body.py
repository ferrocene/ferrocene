#!/usr/bin/env -S uv run
# SPDX-License-Identifier: MIT OR Apache-2.0
# SPDX-FileCopyrightText: The Ferrocene Developers

# /// script
# requires-python = ">=3.12"
# dependencies = ["automations-common"]
#
# [tool.uv.sources]
# automations-common = { path = "../automations-common", editable = true }
# ///

# Helper script to generate the pull request body for a PR pulling the latest
# changes from upstream. It's automatically invoked by automation.py, and can
# be invoked manually if the pull is performed manually (on merge conflicts).

from automations_common import PRLinker
from dataclasses import dataclass
from typing import Optional
import subprocess
import sys

UPSTREAM_REPO = "rust-lang/rust"


def extract_pr_from_message(kind, message):
    """
    Parse commit messages generated by Homu, rust-lang/rust's merge bot.
    """
    parts = message.split(" ")
    if len(parts) < 4 or parts[0] != kind or parts[1] != "merge" or parts[2] != "of":
        return
    pr = parts[3]

    # Future-proof if upstream starts adding repo/name as a prefix
    # https://github.com/rust-lang/homu/pull/145
    if pr.startswith("#"):
        pr = f"{UPSTREAM_REPO}{pr}"
    return pr


def render_changes(origin, base_branch, new_branch):
    """
    Render the changes that happened in the upstream repository since the last
    automatic pull as a bullet list of merged pull requests. This also renders
    pull requests merged as part of a rollup.
    """
    linker = PRLinker()

    # Ensure we have all the commits we need, otherwise the log command
    # below could fail.
    subprocess.run(["git", "fetch", origin], check=True)

    # Obtain commit hash, parent commit hashes and commit message from git
    changes = subprocess.run(
        [
            "git",
            "log",
            "--format=%H|%P|%s",
            "--reverse",
            f"{origin}/{base_branch}..{new_branch}",
            # Force git to consider the above string as a revision range
            # and not a path. Due to the structure of the revision range it
            # could end up being ambiguous.
            "--",
        ],
        check=True,
        text=True,
        stdout=subprocess.PIPE,
    ).stdout.strip()

    # Recreate the commit graph
    commits = {}
    last = None
    for line in changes.split("\n"):
        if not line:
            continue
        print(f"Pre-split line: {line}")
        hash, parents, message = line.split("|", 2)
        parents = parents.split(" ")

        commit = Commit(hash, parents[0], message)
        if len(parents) > 1:
            commit.merge = parents[1]
        commits[hash] = commit
        last = hash

    # If no changes were detected just return nothing
    if last is None:
        return "**Nothing**"

    # When merge conflicts are fixed with separate commits, the latest commit
    # on the branch will not be the merge commit from upstream. In those cases
    # we need to walk back through the commit graph until we find it.
    while commits[last].merge is None:
        print(f"skipping commit {last} as it's not a merge commit", file=sys.stderr)
        last = commits[last].parent
        # When there are no merge commits in the branch, we will reach a point
        # where the parent commit is not in the subset of commits retrieved
        # from the git invocation above. Gracefully handle that.
        if last not in commits:
            return "**Nothing**"

    # Parse the commit graph and generate the list of changes
    changes = ""
    cursor = commits[last].merge
    while cursor in commits:
        commit = commits[cursor]
        cursor = commit.parent

        pr = extract_pr_from_message("Auto", commit.message)
        if pr is None:
            continue
        changes += f"* {linker.link(UPSTREAM_REPO, pr)}\n"

        if commit.merge in commits:
            rollup_cursor = commit.merge
            while rollup_cursor in commits:
                rollup_commit = commits[rollup_cursor]
                rollup_cursor = rollup_commit.parent

                rollup_pr = extract_pr_from_message("Rollup", rollup_commit.message)
                if rollup_pr is None:
                    break
                changes += f"  * {linker.link(UPSTREAM_REPO, rollup_pr)}\n"

    return changes


@dataclass
class Commit:
    hash: str
    parent: str
    message: str
    merge: Optional[str] = None


if __name__ == "__main__":
    if len(sys.argv) < 3 or len(sys.argv) > 4:
        print(
            f"usage: {sys.argv[0]} <origin> <base-branch> <new-branch>", file=sys.stderr
        )
        exit(1)

    new_branch = (
        sys.argv[3]
        if len(sys.argv) == 4
        else subprocess.run(
            ["git", "branch", "--show-current"],
            check=True,
            text=True,
            stdout=subprocess.PIPE,
        ).stdout.strip()
    )

    print(render_changes(sys.argv[1], sys.argv[2], new_branch), end="")
