error[E0597]: `x` does not live long enough
  --> $DIR/migration-note.rs:183:17
   |
LL |     let x = vec![0];
   |         - binding `x` declared here
LL |
LL |     display_len(&x)
   |     ------------^^-
   |     |           |
   |     |           borrowed value does not live long enough
   |     argument requires that `x` is borrowed for `'static`
...
LL | }
   | - `x` dropped here while still borrowed

error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
  --> $DIR/migration-note.rs:20:5
   |
LL |     let a = display_len(&x);
   |                         -- immutable borrow occurs here
...
LL |     x.push(1);
   |     ^^^^^^^^^ mutable borrow occurs here
...
LL |     println!("{a}");
   |               --- immutable borrow later used here
   |
note: this call may capture more lifetimes than intended, because Rust 2024 has adjusted the `impl Trait` lifetime capture rules
  --> $DIR/migration-note.rs:17:13
   |
LL |     let a = display_len(&x);
   |             ^^^^^^^^^^^^^^^
help: add a precise capturing bound to avoid overcapturing
   |
LL | fn display_len<T>(x: &Vec<T>) -> impl Display + use<T> {
   |                                               ++++++++

error[E0597]: `x` does not live long enough
  --> $DIR/migration-note.rs:30:25
   |
LL |     let x = vec![1];
   |         - binding `x` declared here
LL |
LL |     let a = display_len(&x);
   |             ------------^^-
   |             |           |
   |             |           borrowed value does not live long enough
   |             argument requires that `x` is borrowed for `'static`
...
LL | }
   | - `x` dropped here while still borrowed
   |
note: this call may capture more lifetimes than intended, because Rust 2024 has adjusted the `impl Trait` lifetime capture rules
  --> $DIR/migration-note.rs:30:13
   |
LL |     let a = display_len(&x);
   |             ^^^^^^^^^^^^^^^
help: add a precise capturing bound to avoid overcapturing
   |
LL | fn display_len<T>(x: &Vec<T>) -> impl Display + use<T> {
   |                                               ++++++++

error[E0505]: cannot move out of `x` because it is borrowed
  --> $DIR/migration-note.rs:49:8
   |
LL |     let x = vec![1];
   |         - binding `x` declared here
LL |
LL |     let a = display_len(&x);
   |                         -- borrow of `x` occurs here
...
LL |     mv(x);
   |        ^ move out of `x` occurs here
...
LL | }
   | - borrow might be used here, when `a` is dropped and runs the destructor for type `impl std::fmt::Display`
   |
note: this call may capture more lifetimes than intended, because Rust 2024 has adjusted the `impl Trait` lifetime capture rules
  --> $DIR/migration-note.rs:44:13
   |
LL |     let a = display_len(&x);
   |             ^^^^^^^^^^^^^^^
help: add a precise capturing bound to avoid overcapturing
   |
LL | fn display_len<T>(x: &Vec<T>) -> impl Display + use<T> {
   |                                               ++++++++
help: consider cloning the value if the performance cost is acceptable
   |
LL |     let a = display_len(&x.clone());
   |                           ++++++++

error[E0499]: cannot borrow `x` as mutable more than once at a time
  --> $DIR/migration-note.rs:67:5
   |
LL |     let a = display_len_mut(&mut x);
   |                             ------ first mutable borrow occurs here
...
LL |     x.push(1);
   |     ^ second mutable borrow occurs here
...
LL |     println!("{a}");
   |               --- first borrow later used here
   |
note: this call may capture more lifetimes than intended, because Rust 2024 has adjusted the `impl Trait` lifetime capture rules
  --> $DIR/migration-note.rs:64:13
   |
LL |     let a = display_len_mut(&mut x);
   |             ^^^^^^^^^^^^^^^^^^^^^^^
help: add a precise capturing bound to avoid overcapturing
   |
LL | fn display_len_mut<T>(x: &mut Vec<T>) -> impl Display + use<T> {
   |                                                       ++++++++

error[E0597]: `x` does not live long enough
  --> $DIR/migration-note.rs:77:29
   |
LL |     let mut x = vec![1];
   |         ----- binding `x` declared here
LL |
LL |     let a = display_len_mut(&mut x);
   |             ----------------^^^^^^-
   |             |               |
   |             |               borrowed value does not live long enough
   |             argument requires that `x` is borrowed for `'static`
...
LL | }
   | - `x` dropped here while still borrowed
   |
note: this call may capture more lifetimes than intended, because Rust 2024 has adjusted the `impl Trait` lifetime capture rules
  --> $DIR/migration-note.rs:77:13
   |
LL |     let a = display_len_mut(&mut x);
   |             ^^^^^^^^^^^^^^^^^^^^^^^
help: add a precise capturing bound to avoid overcapturing
   |
LL | fn display_len_mut<T>(x: &mut Vec<T>) -> impl Display + use<T> {
   |                                                       ++++++++

error[E0505]: cannot move out of `x` because it is borrowed
  --> $DIR/migration-note.rs:96:8
   |
LL |     let mut x = vec![1];
   |         ----- binding `x` declared here
LL |
LL |     let a = display_len_mut(&mut x);
   |                             ------ borrow of `x` occurs here
...
LL |     mv(x);
   |        ^ move out of `x` occurs here
...
LL | }
   | - borrow might be used here, when `a` is dropped and runs the destructor for type `impl std::fmt::Display`
   |
note: this call may capture more lifetimes than intended, because Rust 2024 has adjusted the `impl Trait` lifetime capture rules
  --> $DIR/migration-note.rs:91:13
   |
LL |     let a = display_len_mut(&mut x);
   |             ^^^^^^^^^^^^^^^^^^^^^^^
help: add a precise capturing bound to avoid overcapturing
   |
LL | fn display_len_mut<T>(x: &mut Vec<T>) -> impl Display + use<T> {
   |                                                       ++++++++
help: consider cloning the value if the performance cost is acceptable
   |
LL |     let a = display_len_mut(&mut x.clone());
   |                                   ++++++++

error[E0506]: cannot assign to `s.f` because it is borrowed
  --> $DIR/migration-note.rs:116:5
   |
LL |     let a = display_field(&s.f);
   |                           ---- `s.f` is borrowed here
...
LL |     s.f = 1;
   |     ^^^^^^^ `s.f` is assigned to here but it was already borrowed
...
LL |     println!("{a}");
   |               --- borrow later used here
   |
note: this call may capture more lifetimes than intended, because Rust 2024 has adjusted the `impl Trait` lifetime capture rules
  --> $DIR/migration-note.rs:113:13
   |
LL |     let a = display_field(&s.f);
   |             ^^^^^^^^^^^^^^^^^^^
help: add a precise capturing bound to avoid overcapturing
   |
LL | fn display_field<T: Copy + Display>(t: &T) -> impl Display + use<T> {
   |                                                            ++++++++

error[E0506]: cannot assign to `s.f` because it is borrowed
  --> $DIR/migration-note.rs:132:5
   |
LL |     let a = display_field(&mut s.f);
   |                           -------- `s.f` is borrowed here
...
LL |     s.f = 1;
   |     ^^^^^^^ `s.f` is assigned to here but it was already borrowed
...
LL |     println!("{a}");
   |               --- borrow later used here
   |
note: this call may capture more lifetimes than intended, because Rust 2024 has adjusted the `impl Trait` lifetime capture rules
  --> $DIR/migration-note.rs:129:13
   |
LL |     let a = display_field(&mut s.f);
   |             ^^^^^^^^^^^^^^^^^^^^^^^
help: add a precise capturing bound to avoid overcapturing
   |
LL | fn display_field<T: Copy + Display>(t: &T) -> impl Display + use<T> {
   |                                                            ++++++++

error[E0503]: cannot use `s.f` because it was mutably borrowed
  --> $DIR/migration-note.rs:144:5
   |
LL |     let a = display_field(&mut s.f);
   |                           -------- `s.f` is borrowed here
...
LL |     s.f;
   |     ^^^ use of borrowed `s.f`
...
LL |     println!("{a}");
   |               --- borrow later used here
   |
note: this call may capture more lifetimes than intended, because Rust 2024 has adjusted the `impl Trait` lifetime capture rules
  --> $DIR/migration-note.rs:141:13
   |
LL |     let a = display_field(&mut s.f);
   |             ^^^^^^^^^^^^^^^^^^^^^^^
help: add a precise capturing bound to avoid overcapturing
   |
LL | fn display_field<T: Copy + Display>(t: &T) -> impl Display + use<T> {
   |                                                            ++++++++

error[E0597]: `z.f` does not live long enough
  --> $DIR/migration-note.rs:160:25
   |
LL |         let z = Z { f: vec![1] };
   |             - binding `z` declared here
LL |
LL |         x = display_len(&z.f);
   |                         ^^^^ borrowed value does not live long enough
...
LL |     }
   |     - `z.f` dropped here while still borrowed
LL |
LL | }
   | - borrow might be used here, when `x` is dropped and runs the destructor for type `impl std::fmt::Display`
   |
   = note: values in a scope are dropped in the opposite order they are defined
note: this call may capture more lifetimes than intended, because Rust 2024 has adjusted the `impl Trait` lifetime capture rules
  --> $DIR/migration-note.rs:160:13
   |
LL |         x = display_len(&z.f);
   |             ^^^^^^^^^^^^^^^^^
help: add a precise capturing bound to avoid overcapturing
   |
LL | fn display_len<T>(x: &Vec<T>) -> impl Display + use<T> {
   |                                               ++++++++

error[E0716]: temporary value dropped while borrowed
  --> $DIR/migration-note.rs:171:40
   |
LL |     let x = { let x = display_len(&mut vec![0]); x };
   |                                        ^^^^^^^ - - borrow later used here
   |                                        |       |
   |                                        |       temporary value is freed at the end of this statement
   |                                        creates a temporary value which is freed while still in use
   |
   = note: consider using a `let` binding to create a longer lived value
note: this call may capture more lifetimes than intended, because Rust 2024 has adjusted the `impl Trait` lifetime capture rules
  --> $DIR/migration-note.rs:171:23
   |
LL |     let x = { let x = display_len(&mut vec![0]); x };
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: add a precise capturing bound to avoid overcapturing
   |
LL | fn display_len<T>(x: &Vec<T>) -> impl Display + use<T> {
   |                                               ++++++++

error: aborting due to 12 previous errors

Some errors have detailed explanations: E0499, E0502, E0503, E0505, E0506, E0597, E0716.
For more information about an error, try `rustc --explain E0499`.
